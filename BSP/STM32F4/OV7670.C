#include "OV7670.h"

#define OV7670_REG_NUM 169
static const uint8_t OV7670_reg[OV7670_REG_NUM][2] =
	{
		{0x3a, 0x04},
		{0x40, 0xd0},
		{0x12, 0x14}, //0x14

		{0x32, 0x80},
		{0x17, 0x16},
		{0x18, 0x04},
		{0x19, 0x02},
		{0x1a, 0x7b}, //0x7a,
		{0x03, 0x0a}, //0x0a,

		{0x0c, 0x00},
		{0x15, 0x00}, //0x00
		{0x3e, 0x00}, //
		{0x70, 0x3a},
		{0x71, 0x35},
		{0x72, 0x11},
		{0x73, 0x00}, //

		{0xa2, 0x02},
		{0x11, 0x00},
		{0x7a, 0x20},
		{0x7b, 0x1c},
		{0x7c, 0x28},

		{0x7d, 0x3c},
		{0x7e, 0x55},
		{0x7f, 0x68},
		{0x80, 0x76},
		{0x81, 0x80},

		{0x82, 0x88},
		{0x83, 0x8f},
		{0x84, 0x96},
		{0x85, 0xa3},
		{0x86, 0xaf},

		{0x87, 0xc4},
		{0x88, 0xd7},
		{0x89, 0xe8},
		{0x13, 0xe0},
		{0x00, 0x00},

		{0x10, 0x00},
		{0x0d, 0x00},
		{0x14, 0x28},
		{0xa5, 0x05},
		{0xab, 0x07},

		{0x24, 0x75},
		{0x25, 0x63},
		{0x26, 0xA5},
		{0x9f, 0x78},
		{0xa0, 0x68},

		{0xa1, 0x03}, //0x0b,
		{0xa6, 0xdf}, //0xd8,
		{0xa7, 0xdf}, //0xd8,
		{0xa8, 0xf0},
		{0xa9, 0x90},

		{0xaa, 0x94},
		{0x13, 0xe5},
		{0x0e, 0x61},
		{0x0f, 0x4b},
		{0x16, 0x02},

		{0x1e, 0x37}, //0x07,
		{0x21, 0x02},
		{0x22, 0x91},
		{0x29, 0x07},
		{0x33, 0x0b},

		{0x35, 0x0b},
		{0x37, 0x1d},
		{0x38, 0x71},
		{0x39, 0x2a},
		{0x3c, 0x78},

		{0x4d, 0x40},
		{0x4e, 0x20},
		{0x69, 0x00},
		{0x6b, 0x50}, //PLL
		{0x74, 0x19},

		{0x8d, 0x4f},
		{0x8e, 0x00},
		{0x8f, 0x00},
		{0x90, 0x00},
		{0x91, 0x00},

		{0x92, 0x00}, //0x19,//0x66
		{0x96, 0x00},
		{0x9a, 0x80},
		{0xb0, 0x84},
		{0xb1, 0x0c},

		{0xb2, 0x0e},
		{0xb3, 0x82},
		{0xb8, 0x0a},
		{0x43, 0x14},
		{0x44, 0xf0},
		{0x45, 0x34},

		{0x46, 0x58},
		{0x47, 0x28},
		{0x48, 0x3a},
		{0x59, 0x88},
		{0x5a, 0x88},

		{0x5b, 0x44},
		{0x5c, 0x67},
		{0x5d, 0x49},
		{0x5e, 0x0e},
		{0x64, 0x04},
		{0x65, 0x20},

		{0x66, 0x05},
		{0x94, 0x04},
		{0x95, 0x08},
		{0x6c, 0x0a},
		{0x6d, 0x55},

		{0x6e, 0x11},
		{0x6f, 0x9f},
		{0x6a, 0x40},
		{0x01, 0x60},
		{0x02, 0x60},
		{0x13, 0xe7},
		{0x15, 0x08},
		{0x4f, 0x80},
		{0x50, 0x80},
		{0x51, 0x00},
		{0x52, 0x22},
		{0x53, 0x5e},
		{0x54, 0x80},
		{0x55, 0x00}, //亮度
		{0x56, 0x60}, //对比度
		{0x57, 0x90},
		{0x58, 0x9e},
		{0x41, 0x08},
		{0x3f, 0x05}, //边缘增强调整
		{0x75, 0x05},
		{0x76, 0xe1},
		{0x4c, 0x0F}, //噪声抑制强度
		{0x77, 0x0a},
		{0x3d, 0xc2}, //0xc0,
		{0x4b, 0x09},
		{0xc9, 0xc8},
		{0x41, 0x38},
		{0x34, 0x11},
		{0x3b, 0x02}, //0x00,//0x02,
		{0xa4, 0x89}, //0x88,
		{0x96, 0x00},
		{0x97, 0x30},
		{0x98, 0x20},
		{0x99, 0x30},
		{0x9a, 0x84},
		{0x9b, 0x29},
		{0x9c, 0x03},
		{0x9d, 0x4c},
		{0x9e, 0x3f},
		{0x78, 0x04},
		{0x79, 0x01},
		{0xc8, 0xf0},
		{0x79, 0x0f},
		{0xc8, 0x00},
		{0x79, 0x10},
		{0xc8, 0x7e},
		{0x79, 0x0a},
		{0xc8, 0x80},
		{0x79, 0x0b},
		{0xc8, 0x01},
		{0x79, 0x0c},
		{0xc8, 0x0f},
		{0x79, 0x0d},
		{0xc8, 0x20},
		{0x79, 0x09},
		{0xc8, 0x80},
		{0x79, 0x02},
		{0xc8, 0xc0},
		{0x79, 0x03},
		{0xc8, 0x40},
		{0x79, 0x05},
		{0xc8, 0x30},
		{0x69, 0xaa}, //
		{0x09, 0x00},
		{0x3b, 0x42},
		{0x2d, 0x01},
};

#ifdef USE_HARDWARE_I2C

extern I2C_HandleTypeDef hi2c2;
void MX_I2C2_Init(void);

static void I2Cx_Error(uint8_t Addr)
{
	/* De-initialize the I2C communication bus */
	HAL_I2C_DeInit(&hi2c2);

	/* Re-Initialize the I2C communication bus */
	MX_I2C2_Init();
}

static void I2C_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
	HAL_StatusTypeDef status = HAL_OK;

	status = HAL_I2C_Mem_Write(&hi2c2, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, &Value, 1, 100);

	/* Check the communication status */
	if (status != HAL_OK)
	{
		/* Execute user timeout callback */
		I2Cx_Error(Addr);
	}
}

static uint8_t I2C_Read(uint8_t Addr, uint8_t Reg)
{
	HAL_StatusTypeDef status = HAL_OK;
	uint8_t Value = 0;

	status = HAL_I2C_Mem_Read(&hi2c2, Addr, Reg, I2C_MEMADD_SIZE_8BIT, &Value, 1, 1000);

	/* Check the communication status */
	if (status != HAL_OK)
	{
		/* Execute user timeout callback */
		I2Cx_Error(Addr);
	}
	return Value;
}

void SCCB_WR_Reg(uint8_t reg, uint8_t data)
{

	I2C_Write(0x42, reg, data);
}

uint8_t SCCB_RD_Reg(uint8_t reg)
{
	return I2C_Read(0x42, reg);
}

#else

void SCCB_SDA_IN(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.Pin = SCCB_SDA_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLUP;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void SCCB_SDA_OUT(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.Pin = SCCB_SDA_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_PULLUP;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

//SCCB起始信号
//当时钟为高的时候,数据线的高到低,为SCCB起始信号
//在激活状态下,SDA和SCL均为低电平
void SCCB_Start(void)
{
	SCCB_SDA_H; //数据线高电平
	SCCB_SCL_H; //在时钟线高的时候数据线由高至低
	HAL_Delay(1);
	SCCB_SDA_L;
	HAL_Delay(1);
	SCCB_SCL_L; //数据线恢复低电平，单操作函数必要
}

//SCCB停止信号
//当时钟为高的时候,数据线的低到高,为SCCB停止信号
//空闲状况下,SDA,SCL均为高电平
void SCCB_Stop(void)
{
	SCCB_SDA_L;
	HAL_Delay(1);
	SCCB_SCL_H;
	HAL_Delay(1);
	SCCB_SDA_H;
	HAL_Delay(1);
}

//产生NA信号
void SCCB_No_Ack(void)
{
	HAL_Delay(1);
	SCCB_SDA_H;
	SCCB_SCL_H;
	HAL_Delay(1);
	SCCB_SCL_L;
	HAL_Delay(1);
	SCCB_SDA_L;
	HAL_Delay(1);
}

//SCCB,写入一个字节
//返回值:0,成功;1,失败.
uint8_t SCCB_WR_Byte(uint8_t dat)
{
	uint8_t j, res;
	for (j = 0; j < 8; j++) //循环8次发送数据
	{
		if (dat & 0x80)
			SCCB_SDA_H;
		else
			SCCB_SDA_L;

		HAL_Delay(1);
		SCCB_SCL_H;
		HAL_Delay(1);
		SCCB_SCL_L;
		dat <<= 1;
	}
	SCCB_SDA_IN();
	HAL_Delay(1);
	SCCB_SCL_H; //接收第九位,以判断是否发送成功
	HAL_Delay(1);
	if (SCCB_READ_SDA == GPIO_PIN_SET)
		res = 1; //SDA=1发送失败，返回1
	else
		res = 0; //SDA=0发送成功，返回0
	SCCB_SCL_L;
	SCCB_SDA_OUT();
	return res;
}

//SCCB 读取一个字节
//在SCL的上升沿,数据锁存
//返回值:读到的数据
uint8_t SCCB_RD_Byte(void)
{
	uint8_t temp = 0, j;
	SCCB_SDA_IN();
	for (j = 8; j > 0; j--) //循环8次接收数据
	{
		HAL_Delay(1);
		SCCB_SCL_H;
		temp = temp << 1;
		if (SCCB_READ_SDA)
			temp++;
		HAL_Delay(1);
		SCCB_SCL_L;
	}
	SCCB_SDA_OUT();
	return temp;
}

//写寄存器
//返回值:0,成功;1,失败.
uint8_t SCCB_WR_Reg(uint8_t reg, uint8_t data)
{
	uint8_t res = 0;
	SCCB_Start();
	if (SCCB_WR_Byte(0x42))
		res = 1;
	HAL_Delay(2);
	if (SCCB_WR_Byte(reg))
		res = 1;
	HAL_Delay(2);
	if (SCCB_WR_Byte(data))
		res = 1;
	SCCB_Stop();
	return res;
}

//读寄存器
//返回值:读到的寄存器值
uint8_t SCCB_RD_Reg(uint8_t reg)
{
	uint8_t val = 0;
	SCCB_Start();		//启动SCCB传输
	SCCB_WR_Byte(0x42); //写器件ID
	HAL_Delay(2);
	SCCB_WR_Byte(reg); //写寄存器地址
	HAL_Delay(2);
	SCCB_Stop();
	HAL_Delay(2);
	//设置寄存器地址后，才是读
	SCCB_Start();
	SCCB_WR_Byte(0x43); //发送读命令
	HAL_Delay(2);
	val = SCCB_RD_Byte(); //读取数据
	SCCB_No_Ack();
	SCCB_Stop();
	return val;
}

uint8_t OV7670_Config(void)
{
	uint8_t i;
	SCCB_WR_Reg(0x12, 0x80); //复位命令 COM7寄存器
	HAL_Delay(10);
	SCCB_WR_Reg(0x12, 0x80);
	HAL_Delay(10);
	/*
	SCCB_WR_Reg(0x8c, 0x00);
	SCCB_WR_Reg(0x3a, 0x04);
	SCCB_WR_Reg(0x40, 0xd0);  //原来10，通用COM15，设置输出数据范围和输出格式
	SCCB_WR_Reg(0x8c, 0x00);
	SCCB_WR_Reg(0x12, 0x14); //输出格式QVGA,原设置为0x14
	SCCB_WR_Reg(0x32, 0x80);
	SCCB_WR_Reg(0x17, 0x16);
	SCCB_WR_Reg(0x18, 0x04);
	SCCB_WR_Reg(0x19, 0x02);
	SCCB_WR_Reg(0x1a, 0x7b);//0x7a,  原来0x7b
	SCCB_WR_Reg(0x03, 0x06);//0x0a,  原来0x06
	SCCB_WR_Reg(0x0c, 0x04);//原来0x04	   com3,设置缩放，省电，模式等
	SCCB_WR_Reg(0x3e, 0x00);//	原来0x00   com14，dcw和pclk缩放设置，以及分频等
	SCCB_WR_Reg(0x70, 0x3a); //原来0x04
	SCCB_WR_Reg(0x71, 0x35); //原来0x35
	SCCB_WR_Reg(0x72, 0x11); //原来0x11
	SCCB_WR_Reg(0x73, 0x00);//原来f0 已改这里改变很重要
	SCCB_WR_Reg(0xa2, 0x00); //原来0x02
	SCCB_WR_Reg(0x11, 0x80); //时钟频率，这里改为最大值，原来为0x80  （改变）
	//SCCB_WR_Reg(0x15 , 0x31);
	SCCB_WR_Reg(0x7a, 0x20); //原来0x20 寄存器7a--89为伽马曲线设置
	SCCB_WR_Reg(0x7b, 0x1c); //原来0x1c
	SCCB_WR_Reg(0x7c, 0x28); //原来0x28
	SCCB_WR_Reg(0x7d, 0x3c); //原来0x3c
	SCCB_WR_Reg(0x7e, 0x55); //原来0x55
	SCCB_WR_Reg(0x7f, 0x68); //原来0x68
	SCCB_WR_Reg(0x80, 0x76); //原来0x76
	SCCB_WR_Reg(0x81, 0x80); //原来0x80
	SCCB_WR_Reg(0x82, 0x88); //原来0x88
	SCCB_WR_Reg(0x83, 0x8f); //原来0x8f
	SCCB_WR_Reg(0x84, 0x96); //原来0x96
	SCCB_WR_Reg(0x85, 0xa3); //原来0xa3
	SCCB_WR_Reg(0x86, 0xaf); //原来0xaf
	SCCB_WR_Reg(0x87, 0xc4); //原来0xc4
	SCCB_WR_Reg(0x88, 0xd7); //原来0xd7
	SCCB_WR_Reg(0x89, 0xe8); //原来0xe8 
	 
	SCCB_WR_Reg(0x32,0xb6);
	
	SCCB_WR_Reg(0x13, 0xff); //原来0xe0 com13 AGC,AWB,AEC使能控制	 （改变）
	SCCB_WR_Reg(0x00, 0x00);//AGC //原来0x00
	SCCB_WR_Reg(0x10, 0x00);//原来0x00  曝光值
	SCCB_WR_Reg(0x0d, 0x00);//原来0x00	 COM4
	SCCB_WR_Reg(0x14, 0x4e);//原来0x28, limit the max gain	自动增益设置 没变化
	SCCB_WR_Reg(0xa5, 0x05); //原来0x05 50Hz bangding step limting
	SCCB_WR_Reg(0xab, 0x07); //原来0x07 60Hz bangding step limting
	SCCB_WR_Reg(0x24, 0x75); //原来0x75 agc/aec-稳定运行区域上限
	SCCB_WR_Reg(0x25, 0x63); //原来0x63 agc/aec-稳定运行区域下限
	SCCB_WR_Reg(0x26, 0xA5); //原来0xa5 agc/aec-快速运行区域
	SCCB_WR_Reg(0x9f, 0x78); //原来0x78 基于直方图的aec/agc的控制1
	SCCB_WR_Reg(0xa0, 0x68); //原来0x68 基于直方图的aec/agc的控制2
//	SCCB_WR_Reg(0xa1, 0x03);//0x0b,
	SCCB_WR_Reg(0xa6, 0xdf);//0xd8, 原来0xdf 基于直方图的aec/agc的控制3
	SCCB_WR_Reg(0xa7, 0xdf);//0xd8, 原来0xdf 基于直方图的aec/agc的控制4
	SCCB_WR_Reg(0xa8, 0xf0); //原来0xf0  基于直方图的aec/agc的控制5
	SCCB_WR_Reg(0xa9, 0x90);  //原来0x90  基于直方图的aec/agc的控制6
	SCCB_WR_Reg(0xaa, 0x94);  //原来0x94  基于直方图的aec/agc的控制7
	//SCCB_WR_Reg(0x13, 0xe5);  //原来0xe5
	SCCB_WR_Reg(0x0e, 0x61);  //原来0x61 COM5
	SCCB_WR_Reg(0x0f, OV7670_Adress);  //原来0x4b COM6
	SCCB_WR_Reg(0x16, 0x02);  //原来0x02 保留
	SCCB_WR_Reg(0x1e, 0x37);//0x07, 原来0x37 水平镜像/竖直翻转使能	 设置为01后发生翻转
	SCCB_WR_Reg(0x21, 0x02);	//原来0x02  保留
	SCCB_WR_Reg(0x22, 0x91);	//原来0x91	保留
	SCCB_WR_Reg(0x29, 0x07);	//原来0x07	保留
	SCCB_WR_Reg(0x33, 0x0b);	//原来0x0b	href控制，改为初始值80时改变
	SCCB_WR_Reg(0x35, 0x0b);	//原来0xe0	保留
	SCCB_WR_Reg(0x37, 0x3f);	//原来0x1d	adc控制
	SCCB_WR_Reg(0x38, 0x01);	//原来0x71	adc和模拟共模控制
	SCCB_WR_Reg(0x39, 0x00);	//原来0x2a	adc偏移控制
	SCCB_WR_Reg(0x3c, 0x78);	//原来0x78	 COM12
	SCCB_WR_Reg(0x4d, 0x40);	//原来0x40	 保留
	SCCB_WR_Reg(0x4e, 0x20);	//原来0x20	 保留
	SCCB_WR_Reg(0x69, 0x00);	//原来0x00	  固定增益控制
	SCCB_WR_Reg(0x6b, 0x0a);   //PLL原来0x00	  pll控制	重要设置
	SCCB_WR_Reg(0x74, 0x19);	//原来0x19	手动数字增益
	SCCB_WR_Reg(0x8d, 0x4f);	//原来0x4f	保留
	SCCB_WR_Reg(0x8e, 0x00);	//原来0x00	保留
	SCCB_WR_Reg(0x8f, 0x00);	//原来0x00	保留
	SCCB_WR_Reg(0x90, 0x00);	//原来0x00	保留
	SCCB_WR_Reg(0x91, 0x00);	//原来0x00	保留
	SCCB_WR_Reg(0x92, 0x00);   //0x19,//0x66	 原来0x00 空行低8位
	SCCB_WR_Reg(0x96, 0x00);	//原来0x00	  保留
	SCCB_WR_Reg(0x9a, 0x80);	//原来0x80	  保留
	SCCB_WR_Reg(0xb0, 0x84);	//原来0xe0	  保留
	SCCB_WR_Reg(0xb1, 0x0c);	//原来0x0c	 ablc设置
	SCCB_WR_Reg(0xb2, 0x0e);	//原来0x0e	  保留
	SCCB_WR_Reg(0xb3, 0x82);	//原来0x82	  ablc target
	SCCB_WR_Reg(0xb8, 0x0a);	//原来0x0a	   保留
	SCCB_WR_Reg(0x43, 0x14);	//原来0x14	  43-48为保留
	SCCB_WR_Reg(0x44, 0xf0);	//原来0xf0
	SCCB_WR_Reg(0x45, 0x34);	//原来0x34
	SCCB_WR_Reg(0x46, 0x58);	//原来0x58
	SCCB_WR_Reg(0x47, 0x28);	//原来0x28
	SCCB_WR_Reg(0x48, 0x3a);	//原来0x3a
	
	SCCB_WR_Reg(0x59, 0x88);	//原来0x88	 51-5e保留
	SCCB_WR_Reg(0x5a, 0x88);	//原来0x88
	SCCB_WR_Reg(0x5b, 0x44);	//原来0x44
	SCCB_WR_Reg(0x5c, 0x67);	//原来0x67
	SCCB_WR_Reg(0x5d, 0x49);	//原来0x49
	SCCB_WR_Reg(0x5e, 0x0e);	//原来0xe0
	
	SCCB_WR_Reg(0x64, 0x04);	//原来0x04	  64-66镜头补偿
	SCCB_WR_Reg(0x65, 0x20);	//原来0x20
	SCCB_WR_Reg(0x66, 0x05);	//原来0x05

	SCCB_WR_Reg(0x94, 0x04);	//原来0x04	94-95镜头补偿
	SCCB_WR_Reg(0x95, 0x08);	//原来0x08	 

	SCCB_WR_Reg(0x6c, 0x0a);	//原来0x0a	6c-6fawb设置
	SCCB_WR_Reg(0x6d, 0x55);	//原来0x55
	SCCB_WR_Reg(0x6e, 0x11);	//原来0x11
	SCCB_WR_Reg(0x6f, 0x9f);   //0x9e for advance AWB	  原来9f

	SCCB_WR_Reg(0x6a, 0x40);	//原来0x40	g通道awb增益
	SCCB_WR_Reg(0x01, 0x40);	//原来0x40	b通道awb增益控制
	SCCB_WR_Reg(0x02, 0x40);	//原来0x40	r通道awb增益控制
	
	//SCCB_WR_Reg(0x13, 0xe7);	//原来0xe7
	SCCB_WR_Reg(0x15, 0x00);   //00  cmos10  含有pclk输出选择
	SCCB_WR_Reg(0x4f, 0x80);	//原来0x80	以下为色彩矩阵系数设置
	SCCB_WR_Reg(0x50, 0x80);	//原来0x80
	SCCB_WR_Reg(0x51, 0x00);	//原来0x00
	SCCB_WR_Reg(0x52, 0x22);	//原来0x22
	SCCB_WR_Reg(0x53, 0x5e);	//原来0x5e
	SCCB_WR_Reg(0x54, 0x80);	//原来0x80
	SCCB_WR_Reg(0x58, 0x9e);	//原来0x9e

	SCCB_WR_Reg(0x41, 0x08);	//原来0x08	com16 以下为边缘设置
	SCCB_WR_Reg(0x3f, 0x00);	//原来0x00  边缘增强调整
	SCCB_WR_Reg(0x75, 0x05);	//原来0x05
	SCCB_WR_Reg(0x76, 0xe1);	//原来0xe1

	SCCB_WR_Reg(0x4c, 0x00);	//原来0x00  噪声抑制强度
	SCCB_WR_Reg(0x77, 0x01);	//原来0x01	噪声去除偏移
	
	SCCB_WR_Reg(0x3d, 0xc1);	//0xc0,	   com13 输出设置
	SCCB_WR_Reg(0x4b, 0x09);	//原来0x09 寄存器4b设置
	SCCB_WR_Reg(0xc9, 0x60);	//原来0x60	 饱和度控制
	//SCCB_WR_Reg(0x41, 0x38);	//原来0x38	  com16边缘设置设置
	SCCB_WR_Reg(0x56, 0x40);//0x40,  change according to Jim's request	对比度控制
	SCCB_WR_Reg(0x34, 0x11);	//原来0x11	  感光阵列参考电压控制
	SCCB_WR_Reg(0x3b, 0x02);//0x00,//原来0x02,	  com11控制
	SCCB_WR_Reg(0xa4, 0x89);//0x88, 原来89 nt控制  
	
	SCCB_WR_Reg(0x96, 0x00);	//原来0x00  以下96-9c保留
	SCCB_WR_Reg(0x97, 0x30);	//原来0x30
	SCCB_WR_Reg(0x98, 0x20);	//原来0x20
	SCCB_WR_Reg(0x99, 0x30);	//原来0x30
	SCCB_WR_Reg(0x9a, 0x84);	//原来0x84
	SCCB_WR_Reg(0x9b, 0x29);	//原来0x29
	SCCB_WR_Reg(0x9c, 0x03);	//原来0x03
	SCCB_WR_Reg(0x9d, 0x4c);	//原来0x4c	50HZ条纹滤波的值
	SCCB_WR_Reg(0x9e, 0x3f);	//原来0x3f	60HZ条纹滤波的值

	SCCB_WR_Reg(0x09, 0x00);	//原来0x00 通用控制器com2
	SCCB_WR_Reg(0x3b, 0xc2);//0x82,//0xc0,//原来0xc2,	//night mode 原来0xc2
	*/

	for (i = 0; i < OV7670_REG_NUM; i++)
	{
		if (SCCB_WR_Reg(OV7670_reg[i][0], OV7670_reg[i][1]))
			return 1;
	}
	return 0;
}

//(140,16,640,480) is good for VGA
//(272,16,320,240) is good for QVGA
// config_OV7670_window
void OV7670_Set_window(uint16_t startx, uint16_t starty, uint16_t width, uint16_t height)
{
	uint16_t endx;
	uint16_t endy; // "v*2"必须
	uint8_t temp_reg1, temp_reg2;
	uint8_t temp = 0;

	endx = (startx + width);
	endy = (starty + height + height); // "v*2"必须
	temp_reg1 = SCCB_RD_Reg(0x03);
	HAL_Delay(10);
	temp_reg1 = SCCB_RD_Reg(0x03);
	temp_reg1 &= 0xf0;
	temp_reg2 = SCCB_RD_Reg(0x32);
	temp_reg2 &= 0xc0;

	// Horizontal
	temp = temp_reg2 | ((endx & 0x7) << 3) | (startx & 0x7);
	SCCB_WR_Reg(0x32, temp);
	HAL_Delay(10);
	SCCB_WR_Reg(0x32, temp);
	temp = (startx & 0x7F8) >> 3;
	SCCB_WR_Reg(0x17, temp);
	temp = (endx & 0x7F8) >> 3;
	SCCB_WR_Reg(0x18, temp);

	// Vertical
	temp = temp_reg1 | ((endy & 0x3) << 2) | (starty & 0x3);
	SCCB_WR_Reg(0x03, temp);
	temp = starty >> 2;
	SCCB_WR_Reg(0x19, temp);
	temp = endy >> 2;
	SCCB_WR_Reg(0x1A, temp);
}

uint8_t OV7670_Init(void)
{
	uint8_t MIDH, MIDL; //Manufactrue ID
	uint8_t PID, VER;
	uint8_t tmp;

	OV7670_PDWN_L;

	HAL_Delay(50);
	OV7670_RST_L;
	HAL_Delay(200);
	OV7670_RST_H;

	MIDH = SCCB_RD_Reg(0x1C); //7F
	HAL_Delay(10);
	MIDH = SCCB_RD_Reg(0x1C); //7F
	MIDL = SCCB_RD_Reg(0x1D); //A2
	PID = SCCB_RD_Reg(0x0A);  //76
	VER = SCCB_RD_Reg(0x0B);  //73
	tmp = SCCB_RD_Reg(0x11);  //01
	HAL_Delay(10);
	SCCB_WR_Reg(0x11, 0x81);
	HAL_Delay(10);
	SCCB_WR_Reg(0x11, 0x81);
	HAL_Delay(10);
	tmp = SCCB_RD_Reg(0x11); //01
	HAL_Delay(10);
	tmp = SCCB_RD_Reg(0x11); //01

	if ((MIDH != 0x7F) || (MIDL != 0xA2) || PID != 0x76 || VER != 0x73 || tmp != 0x81)
	{
		return 0;
	}

	else
	{

		OV7670_Config();
		OV7670_Set_window(184 + 80, 10 + 60, 160, 120);
	}
	return 1;
}

#endif

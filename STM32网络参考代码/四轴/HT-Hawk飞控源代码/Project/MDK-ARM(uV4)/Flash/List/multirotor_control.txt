; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -o.\flash\obj\multirotor_control.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\multirotor_control.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\multirotor_control.crf ..\..\User\Function\MultiRotor_control\MultiRotor_control.c]
                          THUMB

                          AREA ||i.Attitude_RatePID||, CODE, READONLY, ALIGN=2

                  Attitude_RatePID PROC
;;;123    /*====================================================================================================*/
;;;124    void Attitude_RatePID(void)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;125    {
;;;126        fp32 E_pitch,E_roll,E_yaw;
;;;127    	
;;;128    	            // 计算偏差  
;;;129    	E_pitch = ctrl.pitch.shell.pid_out - sensor.gyro.averag.y;
000004  4a9a              LDR      r2,|L1.624|
000006  6c11              LDR      r1,[r2,#0x40]
000008  4a9a              LDR      r2,|L1.628|
00000a  6a50              LDR      r0,[r2,#0x24]
00000c  f7fffffe          BL       __aeabi_fsub
000010  9002              STR      r0,[sp,#8]
;;;130    	E_roll  = ctrl.roll.shell.pid_out  - sensor.gyro.averag.x;
000012  4a97              LDR      r2,|L1.624|
000014  6bd1              LDR      r1,[r2,#0x3c]
000016  4a97              LDR      r2,|L1.628|
000018  6ed0              LDR      r0,[r2,#0x6c]
00001a  f7fffffe          BL       __aeabi_fsub
00001e  9001              STR      r0,[sp,#4]
;;;131    	E_yaw   = ctrl.yaw.shell.pid_out   - sensor.gyro.averag.z;
000020  4a93              LDR      r2,|L1.624|
000022  6c51              LDR      r1,[r2,#0x44]
000024  4a93              LDR      r2,|L1.628|
000026  f8d200b4          LDR      r0,[r2,#0xb4]
00002a  f7fffffe          BL       __aeabi_fsub
00002e  9000              STR      r0,[sp,#0]
;;;132    	
;;;133    	            // 积分
;;;134    	ctrl.pitch.core.increment += E_pitch;
000030  4990              LDR      r1,|L1.628|
000032  6b48              LDR      r0,[r1,#0x34]
000034  9902              LDR      r1,[sp,#8]
000036  f7fffffe          BL       __aeabi_fadd
00003a  4601              MOV      r1,r0
00003c  488d              LDR      r0,|L1.628|
00003e  6341              STR      r1,[r0,#0x34]
;;;135    	ctrl.roll.core.increment  += E_roll;
000040  4601              MOV      r1,r0
000042  6fc8              LDR      r0,[r1,#0x7c]
000044  9901              LDR      r1,[sp,#4]
000046  f7fffffe          BL       __aeabi_fadd
00004a  4601              MOV      r1,r0
00004c  4889              LDR      r0,|L1.628|
00004e  67c1              STR      r1,[r0,#0x7c]
;;;136    	ctrl.yaw.core.increment   += E_yaw;
000050  4601              MOV      r1,r0
000052  f8d100c4          LDR      r0,[r1,#0xc4]
000056  9900              LDR      r1,[sp,#0]
000058  f7fffffe          BL       __aeabi_fadd
00005c  4601              MOV      r1,r0
00005e  4885              LDR      r0,|L1.628|
000060  f8c010c4          STR      r1,[r0,#0xc4]
;;;137    	
;;;138    	            // 积分限幅
;;;139    	ctrl.pitch.core.increment = data_limit(ctrl.pitch.core.increment,20,-20);
000064  4601              MOV      r1,r0
000066  4a84              LDR      r2,|L1.632|
000068  6b48              LDR      r0,[r1,#0x34]
00006a  4984              LDR      r1,|L1.636|
00006c  f7fffffe          BL       data_limit
000070  4601              MOV      r1,r0
000072  4880              LDR      r0,|L1.628|
000074  6341              STR      r1,[r0,#0x34]
;;;140    	ctrl.roll.core.increment  = data_limit(ctrl.roll.core.increment,20,-20);		
000076  4601              MOV      r1,r0
000078  4a7f              LDR      r2,|L1.632|
00007a  6fc8              LDR      r0,[r1,#0x7c]
00007c  497f              LDR      r1,|L1.636|
00007e  f7fffffe          BL       data_limit
000082  4601              MOV      r1,r0
000084  487b              LDR      r0,|L1.628|
000086  67c1              STR      r1,[r0,#0x7c]
;;;141    	ctrl.yaw.core.increment   = data_limit(ctrl.yaw.core.increment,20,-20);
000088  4601              MOV      r1,r0
00008a  4a7b              LDR      r2,|L1.632|
00008c  f8d100c4          LDR      r0,[r1,#0xc4]
000090  497a              LDR      r1,|L1.636|
000092  f7fffffe          BL       data_limit
000096  4601              MOV      r1,r0
000098  4876              LDR      r0,|L1.628|
00009a  f8c010c4          STR      r1,[r0,#0xc4]
;;;142    	//=========================================================================================================//
;;;143    	                          //比例控制
;;;144    	ctrl.pitch.core.kp_out = ctrl.pitch.core.kp * E_pitch;
00009e  4601              MOV      r1,r0
0000a0  6a88              LDR      r0,[r1,#0x28]
0000a2  9902              LDR      r1,[sp,#8]
0000a4  f7fffffe          BL       __aeabi_fmul
0000a8  4601              MOV      r1,r0
0000aa  4872              LDR      r0,|L1.628|
0000ac  63c1              STR      r1,[r0,#0x3c]
;;;145    	ctrl.roll.core.kp_out  = ctrl.roll.core.kp  * E_roll;
0000ae  4601              MOV      r1,r0
0000b0  6f08              LDR      r0,[r1,#0x70]
0000b2  9901              LDR      r1,[sp,#4]
0000b4  f7fffffe          BL       __aeabi_fmul
0000b8  4601              MOV      r1,r0
0000ba  486e              LDR      r0,|L1.628|
0000bc  f8c01084          STR      r1,[r0,#0x84]
;;;146    	ctrl.yaw.core.kp_out   = ctrl.yaw.core.kp   * E_yaw;
0000c0  4601              MOV      r1,r0
0000c2  f8d100b8          LDR      r0,[r1,#0xb8]
0000c6  9900              LDR      r1,[sp,#0]
0000c8  f7fffffe          BL       __aeabi_fmul
0000cc  4601              MOV      r1,r0
0000ce  4869              LDR      r0,|L1.628|
0000d0  f8c010cc          STR      r1,[r0,#0xcc]
;;;147    	                          //积分控制
;;;148    	ctrl.pitch.core.ki_out = ctrl.pitch.core.ki * ctrl.pitch.core.increment;
0000d4  4602              MOV      r2,r0
0000d6  6b51              LDR      r1,[r2,#0x34]
0000d8  6ad0              LDR      r0,[r2,#0x2c]
0000da  f7fffffe          BL       __aeabi_fmul
0000de  4601              MOV      r1,r0
0000e0  4864              LDR      r0,|L1.628|
0000e2  6401              STR      r1,[r0,#0x40]
;;;149        ctrl.roll.core.ki_out  = ctrl.roll.core.ki  * ctrl.roll.core.increment;
0000e4  4602              MOV      r2,r0
0000e6  6fd1              LDR      r1,[r2,#0x7c]
0000e8  6f50              LDR      r0,[r2,#0x74]
0000ea  f7fffffe          BL       __aeabi_fmul
0000ee  4601              MOV      r1,r0
0000f0  4860              LDR      r0,|L1.628|
0000f2  f8c01088          STR      r1,[r0,#0x88]
;;;150    	ctrl.yaw.core.ki_out   = ctrl.yaw.core.ki   * ctrl.yaw.core.increment;
0000f6  4602              MOV      r2,r0
0000f8  f8d210c4          LDR      r1,[r2,#0xc4]
0000fc  f8d200bc          LDR      r0,[r2,#0xbc]
000100  f7fffffe          BL       __aeabi_fmul
000104  4601              MOV      r1,r0
000106  485b              LDR      r0,|L1.628|
000108  f8c010d0          STR      r1,[r0,#0xd0]
;;;151    	
;;;152    	                          //微分控制
;;;153    	ctrl.pitch.core.kd_out = ctrl.pitch.core.kd * (sensor.gyro.histor.y - sensor.gyro.averag.y)*33;
00010c  4a58              LDR      r2,|L1.624|
00010e  6c11              LDR      r1,[r2,#0x40]
000110  6cd0              LDR      r0,[r2,#0x4c]
000112  f7fffffe          BL       __aeabi_fsub
000116  4605              MOV      r5,r0
000118  4856              LDR      r0,|L1.628|
00011a  6b01              LDR      r1,[r0,#0x30]
00011c  4628              MOV      r0,r5
00011e  f7fffffe          BL       __aeabi_fmul
000122  4604              MOV      r4,r0
000124  4956              LDR      r1,|L1.640|
000126  f7fffffe          BL       __aeabi_fmul
00012a  4601              MOV      r1,r0
00012c  4851              LDR      r0,|L1.628|
00012e  6441              STR      r1,[r0,#0x44]
;;;154    	ctrl.roll.core.kd_out  = ctrl.roll.core.kd  * (sensor.gyro.histor.x - sensor.gyro.averag.x)*33;
000130  4a4f              LDR      r2,|L1.624|
000132  6bd1              LDR      r1,[r2,#0x3c]
000134  6c90              LDR      r0,[r2,#0x48]
000136  f7fffffe          BL       __aeabi_fsub
00013a  4605              MOV      r5,r0
00013c  484d              LDR      r0,|L1.628|
00013e  6f81              LDR      r1,[r0,#0x78]
000140  4628              MOV      r0,r5
000142  f7fffffe          BL       __aeabi_fmul
000146  4604              MOV      r4,r0
000148  494d              LDR      r1,|L1.640|
00014a  f7fffffe          BL       __aeabi_fmul
00014e  4601              MOV      r1,r0
000150  4848              LDR      r0,|L1.628|
000152  f8c0108c          STR      r1,[r0,#0x8c]
;;;155    	ctrl.yaw.core.kd_out   = ctrl.yaw.core.kd   * (sensor.gyro.histor.z - sensor.gyro.averag.z)*33;	
000156  4a46              LDR      r2,|L1.624|
000158  6c51              LDR      r1,[r2,#0x44]
00015a  6d10              LDR      r0,[r2,#0x50]
00015c  f7fffffe          BL       __aeabi_fsub
000160  4605              MOV      r5,r0
000162  4844              LDR      r0,|L1.628|
000164  f8d010c0          LDR      r1,[r0,#0xc0]
000168  4628              MOV      r0,r5
00016a  f7fffffe          BL       __aeabi_fmul
00016e  4604              MOV      r4,r0
000170  4943              LDR      r1,|L1.640|
000172  f7fffffe          BL       __aeabi_fmul
000176  4601              MOV      r1,r0
000178  483e              LDR      r0,|L1.628|
00017a  f8c010d4          STR      r1,[r0,#0xd4]
;;;156    	
;;;157    	sensor.gyro.histor.y = sensor.gyro.averag.y;
00017e  483c              LDR      r0,|L1.624|
000180  6c01              LDR      r1,[r0,#0x40]
000182  64c1              STR      r1,[r0,#0x4c]
;;;158    	sensor.gyro.histor.x = sensor.gyro.averag.x; 
000184  6bc1              LDR      r1,[r0,#0x3c]
000186  6481              STR      r1,[r0,#0x48]
;;;159        sensor.gyro.histor.z = sensor.gyro.averag.z;	
000188  6c41              LDR      r1,[r0,#0x44]
00018a  6501              STR      r1,[r0,#0x50]
;;;160    	//=========================================================================================================//
;;;161    	//内环PID输出
;;;162    	ctrl.pitch.core.pid_out = ctrl.pitch.core.kp_out + ctrl.pitch.core.ki_out + ctrl.pitch.core.kd_out;
00018c  4a39              LDR      r2,|L1.628|
00018e  6c11              LDR      r1,[r2,#0x40]
000190  6bd0              LDR      r0,[r2,#0x3c]
000192  f7fffffe          BL       __aeabi_fadd
000196  4604              MOV      r4,r0
000198  4836              LDR      r0,|L1.628|
00019a  6c41              LDR      r1,[r0,#0x44]
00019c  4620              MOV      r0,r4
00019e  f7fffffe          BL       __aeabi_fadd
0001a2  4601              MOV      r1,r0
0001a4  4833              LDR      r0,|L1.628|
0001a6  6481              STR      r1,[r0,#0x48]
;;;163    	ctrl.roll.core.pid_out  = ctrl.roll.core.kp_out  + ctrl.roll.core.ki_out  + ctrl.roll.core.kd_out;
0001a8  4602              MOV      r2,r0
0001aa  f8d21088          LDR      r1,[r2,#0x88]
0001ae  f8d20084          LDR      r0,[r2,#0x84]
0001b2  f7fffffe          BL       __aeabi_fadd
0001b6  4604              MOV      r4,r0
0001b8  482e              LDR      r0,|L1.628|
0001ba  f8d0108c          LDR      r1,[r0,#0x8c]
0001be  4620              MOV      r0,r4
0001c0  f7fffffe          BL       __aeabi_fadd
0001c4  4601              MOV      r1,r0
0001c6  482b              LDR      r0,|L1.628|
0001c8  f8c01090          STR      r1,[r0,#0x90]
;;;164    	ctrl.yaw.core.pid_out   = ctrl.yaw.core.kp_out   + ctrl.yaw.core.kd_out;
0001cc  4602              MOV      r2,r0
0001ce  f8d210d4          LDR      r1,[r2,#0xd4]
0001d2  f8d200cc          LDR      r0,[r2,#0xcc]
0001d6  f7fffffe          BL       __aeabi_fadd
0001da  4601              MOV      r1,r0
0001dc  4825              LDR      r0,|L1.628|
0001de  f8c010d8          STR      r1,[r0,#0xd8]
;;;165    	//=========================================================================================================//
;;;166    	//总PID输出 内外环PID输出与外环PID输出互补融合
;;;167    	ctrl.pitch.core.pid_out = ctrl.pitch.core.pid_out*0.8 + ctrl.pitch.shell.pid_out/2;
0001e2  4601              MOV      r1,r0
0001e4  6a48              LDR      r0,[r1,#0x24]
0001e6  f04f4180          MOV      r1,#0x40000000
0001ea  f7fffffe          BL       __aeabi_fdiv
0001ee  4682              MOV      r10,r0
0001f0  f7fffffe          BL       __aeabi_f2d
0001f4  4606              MOV      r6,r0
0001f6  460f              MOV      r7,r1
0001f8  491e              LDR      r1,|L1.628|
0001fa  6c88              LDR      r0,[r1,#0x48]
0001fc  f7fffffe          BL       __aeabi_f2d
000200  4682              MOV      r10,r0
000202  4a20              LDR      r2,|L1.644|
000204  4b20              LDR      r3,|L1.648|
000206  f7fffffe          BL       __aeabi_dmul
00020a  4680              MOV      r8,r0
00020c  4632              MOV      r2,r6
00020e  463b              MOV      r3,r7
000210  f7fffffe          BL       __aeabi_dadd
000214  4604              MOV      r4,r0
000216  f7fffffe          BL       __aeabi_d2f
00021a  4601              MOV      r1,r0
00021c  4815              LDR      r0,|L1.628|
00021e  6481              STR      r1,[r0,#0x48]
;;;168    	ctrl.roll.core.pid_out  = ctrl.roll.core.pid_out *0.8 + ctrl.roll.shell.pid_out/2; 
000220  4601              MOV      r1,r0
000222  6ec8              LDR      r0,[r1,#0x6c]
000224  f04f4180          MOV      r1,#0x40000000
000228  f7fffffe          BL       __aeabi_fdiv
00022c  4680              MOV      r8,r0
00022e  f7fffffe          BL       __aeabi_f2d
000232  4604              MOV      r4,r0
000234  460d              MOV      r5,r1
000236  490f              LDR      r1,|L1.628|
000238  f8d10090          LDR      r0,[r1,#0x90]
00023c  f7fffffe          BL       __aeabi_f2d
000240  4680              MOV      r8,r0
000242  4a10              LDR      r2,|L1.644|
000244  4b10              LDR      r3,|L1.648|
000246  f7fffffe          BL       __aeabi_dmul
00024a  4606              MOV      r6,r0
00024c  4622              MOV      r2,r4
00024e  462b              MOV      r3,r5
000250  f7fffffe          BL       __aeabi_dadd
000254  4682              MOV      r10,r0
000256  f7fffffe          BL       __aeabi_d2f
00025a  4601              MOV      r1,r0
00025c  4805              LDR      r0,|L1.628|
00025e  f8c01090          STR      r1,[r0,#0x90]
;;;169    	ctrl.yaw.core.pid_out   = ctrl.yaw.core.pid_out;
000262  f8d010d8          LDR      r1,[r0,#0xd8]
000266  f8c010d8          STR      r1,[r0,#0xd8]
;;;170      //《PID输出数值的范围是多大》
;;;171    }
00026a  e8bd8ffe          POP      {r1-r11,pc}
;;;172    /*====================================================================================================*/
                          ENDP

00026e  0000              DCW      0x0000
                  |L1.624|
                          DCD      sensor
                  |L1.628|
                          DCD      ctrl
                  |L1.632|
                          DCD      0xc1a00000
                  |L1.636|
                          DCD      0x41a00000
                  |L1.640|
                          DCD      0x42040000
                  |L1.644|
                          DCD      0x9999999a
                  |L1.648|
                          DCD      0x3fe99999

                          AREA ||i.CONTROL||, CODE, READONLY, ALIGN=2

                  CONTROL PROC
;;;73     /*====================================================================================================*/
;;;74     void CONTROL(struct _target Goal)      //传入实参 【target】
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;75     {
;;;76     	float  deviation_pitch,deviation_roll,deviation_yaw;  //偏差定义
;;;77     	
;;;78     	if(ctrl.ctrlRate >= 2)             //==================================【内环两次PID控制 外环进行一次PID控制】
000004  485f              LDR      r0,|L2.388|
000006  7800              LDRB     r0,[r0,#0]  ; ctrl
000008  2802              CMP      r0,#2
00000a  db7d              BLT      |L2.264|
;;;79     	{
;;;80     		                               //==================================【【外环(角度环)PID】】
;;;81     		//【俯仰计算】                  //【目标角度――测出角度】
;;;82     	    deviation_pitch = Goal.Pitch - AngE.Pitch;
00000c  4a5e              LDR      r2,|L2.392|
00000e  6811              LDR      r1,[r2,#0]  ; AngE
000010  9800              LDR      r0,[sp,#0]
000012  f7fffffe          BL       __aeabi_fsub
000016  4606              MOV      r6,r0
;;;83     		ctrl.pitch.shell.increment += deviation_pitch;   //横滚角误差积分
000018  495a              LDR      r1,|L2.388|
00001a  6908              LDR      r0,[r1,#0x10]
00001c  4631              MOV      r1,r6
00001e  f7fffffe          BL       __aeabi_fadd
000022  4958              LDR      r1,|L2.388|
000024  6108              STR      r0,[r1,#0x10]
;;;84     		
;;;85     		//limit for the max increment  积分限幅
;;;86     		ctrl.pitch.shell.increment = data_limit(ctrl.pitch.shell.increment,ctrl.pitch.shell.increment_max,-ctrl.pitch.shell.increment_max);
000026  4608              MOV      r0,r1
000028  6940              LDR      r0,[r0,#0x14]
00002a  f0804500          EOR      r5,r0,#0x80000000
00002e  460a              MOV      r2,r1
000030  6951              LDR      r1,[r2,#0x14]
000032  6910              LDR      r0,[r2,#0x10]
000034  462a              MOV      r2,r5
000036  f7fffffe          BL       data_limit
00003a  4952              LDR      r1,|L2.388|
00003c  6108              STR      r0,[r1,#0x10]
;;;87         //==========================================【横滚角PI输出】==============================================
;;;88     		ctrl.pitch.shell.pid_out = ctrl.pitch.shell.kp * deviation_pitch + ctrl.pitch.shell.ki * ctrl.pitch.shell.increment;
00003e  460a              MOV      r2,r1
000040  6911              LDR      r1,[r2,#0x10]
000042  6890              LDR      r0,[r2,#8]
000044  f7fffffe          BL       __aeabi_fmul
000048  4605              MOV      r5,r0
00004a  494e              LDR      r1,|L2.388|
00004c  6848              LDR      r0,[r1,#4]  ; ctrl
00004e  4631              MOV      r1,r6
000050  f7fffffe          BL       __aeabi_fmul
000054  4680              MOV      r8,r0
000056  4629              MOV      r1,r5
000058  f7fffffe          BL       __aeabi_fadd
00005c  4949              LDR      r1,|L2.388|
00005e  6248              STR      r0,[r1,#0x24]
;;;89     		
;;;90     		//【横滚计算】
;;;91     		deviation_roll = Goal.Roll - AngE.Roll;
000060  4a49              LDR      r2,|L2.392|
000062  6851              LDR      r1,[r2,#4]  ; AngE
000064  9801              LDR      r0,[sp,#4]
000066  f7fffffe          BL       __aeabi_fsub
00006a  4607              MOV      r7,r0
;;;92     		ctrl.roll.shell.increment += deviation_roll;     //俯仰角误差积分
00006c  4945              LDR      r1,|L2.388|
00006e  6d88              LDR      r0,[r1,#0x58]
000070  4639              MOV      r1,r7
000072  f7fffffe          BL       __aeabi_fadd
000076  4943              LDR      r1,|L2.388|
000078  6588              STR      r0,[r1,#0x58]
;;;93     		
;;;94     		//limit for the max increment  积分限幅
;;;95     		ctrl.roll.shell.increment = data_limit(ctrl.roll.shell.increment,ctrl.roll.shell.increment_max,-ctrl.roll.shell.increment_max);
00007a  4608              MOV      r0,r1
00007c  6dc0              LDR      r0,[r0,#0x5c]
00007e  f0804500          EOR      r5,r0,#0x80000000
000082  460a              MOV      r2,r1
000084  6dd1              LDR      r1,[r2,#0x5c]
000086  6d90              LDR      r0,[r2,#0x58]
000088  462a              MOV      r2,r5
00008a  f7fffffe          BL       data_limit
00008e  493d              LDR      r1,|L2.388|
000090  6588              STR      r0,[r1,#0x58]
;;;96         //==========================================【俯仰角PI输出】==============================================
;;;97     		ctrl.roll.shell.pid_out  = ctrl.roll.shell.kp * deviation_roll + ctrl.roll.shell.ki * ctrl.roll.shell.increment;
000092  460a              MOV      r2,r1
000094  6d91              LDR      r1,[r2,#0x58]
000096  6d10              LDR      r0,[r2,#0x50]
000098  f7fffffe          BL       __aeabi_fmul
00009c  4605              MOV      r5,r0
00009e  4939              LDR      r1,|L2.388|
0000a0  6cc8              LDR      r0,[r1,#0x4c]  ; ctrl
0000a2  4639              MOV      r1,r7
0000a4  f7fffffe          BL       __aeabi_fmul
0000a8  4680              MOV      r8,r0
0000aa  4629              MOV      r1,r5
0000ac  f7fffffe          BL       __aeabi_fadd
0000b0  4934              LDR      r1,|L2.388|
0000b2  66c8              STR      r0,[r1,#0x6c]
;;;98     		
;;;99     		//【航向计算】
;;;100           if((Goal.Yaw - AngE.Yaw)>180 || (Goal.Yaw - AngE.Yaw)<-180){
0000b4  4a34              LDR      r2,|L2.392|
0000b6  6891              LDR      r1,[r2,#8]  ; AngE
0000b8  9802              LDR      r0,[sp,#8]
0000ba  f7fffffe          BL       __aeabi_fsub
0000be  4605              MOV      r5,r0
0000c0  4932              LDR      r1,|L2.396|
0000c2  f7fffffe          BL       __aeabi_cfrcmple
0000c6  d309              BCC      |L2.220|
0000c8  4a2f              LDR      r2,|L2.392|
0000ca  6891              LDR      r1,[r2,#8]  ; AngE
0000cc  9802              LDR      r0,[sp,#8]
0000ce  f7fffffe          BL       __aeabi_fsub
0000d2  4605              MOV      r5,r0
0000d4  492e              LDR      r1,|L2.400|
0000d6  f7fffffe          BL       __aeabi_cfcmple
0000da  d236              BCS      |L2.330|
                  |L2.220|
;;;101           if(Goal.Yaw>0 && AngE.Yaw<0)  deviation_yaw= (-180 - AngE.Yaw) +(Goal.Yaw - 180);
0000dc  2100              MOVS     r1,#0
0000de  9802              LDR      r0,[sp,#8]
0000e0  f7fffffe          BL       __aeabi_cfrcmple
0000e4  d216              BCS      |L2.276|
0000e6  4928              LDR      r1,|L2.392|
0000e8  6888              LDR      r0,[r1,#8]  ; AngE
0000ea  2100              MOVS     r1,#0
0000ec  f7fffffe          BL       __aeabi_cfcmple
0000f0  d210              BCS      |L2.276|
0000f2  4926              LDR      r1,|L2.396|
0000f4  9802              LDR      r0,[sp,#8]
0000f6  f7fffffe          BL       __aeabi_fsub
0000fa  4605              MOV      r5,r0
0000fc  4822              LDR      r0,|L2.392|
0000fe  6881              LDR      r1,[r0,#8]  ; AngE
000100  4823              LDR      r0,|L2.400|
000102  f7fffffe          BL       __aeabi_fsub
000106  e000              B        |L2.266|
                  |L2.264|
000108  e030              B        |L2.364|
                  |L2.266|
00010a  4680              MOV      r8,r0
00010c  4629              MOV      r1,r5
00010e  f7fffffe          BL       __aeabi_fadd
000112  4604              MOV      r4,r0
                  |L2.276|
;;;102           if(Goal.Yaw<0 && AngE.Yaw>0)  deviation_yaw= (180 - AngE.Yaw) +(Goal.Yaw + 180);
000114  2100              MOVS     r1,#0
000116  9802              LDR      r0,[sp,#8]
000118  f7fffffe          BL       __aeabi_cfcmple
00011c  d21b              BCS      |L2.342|
00011e  491a              LDR      r1,|L2.392|
000120  6888              LDR      r0,[r1,#8]  ; AngE
000122  2100              MOVS     r1,#0
000124  f7fffffe          BL       __aeabi_cfrcmple
000128  d215              BCS      |L2.342|
00012a  4918              LDR      r1,|L2.396|
00012c  9802              LDR      r0,[sp,#8]
00012e  f7fffffe          BL       __aeabi_fadd
000132  4605              MOV      r5,r0
000134  4814              LDR      r0,|L2.392|
000136  6881              LDR      r1,[r0,#8]  ; AngE
000138  4814              LDR      r0,|L2.396|
00013a  f7fffffe          BL       __aeabi_fsub
00013e  4680              MOV      r8,r0
000140  4629              MOV      r1,r5
000142  f7fffffe          BL       __aeabi_fadd
000146  4604              MOV      r4,r0
000148  e005              B        |L2.342|
                  |L2.330|
;;;103        }
;;;104        else  deviation_yaw = Goal.Yaw - AngE.Yaw; //航向角误差       此处对航向角的要求不是很严格
00014a  4a0f              LDR      r2,|L2.392|
00014c  6891              LDR      r1,[r2,#8]  ; AngE
00014e  9802              LDR      r0,[sp,#8]
000150  f7fffffe          BL       __aeabi_fsub
000154  4604              MOV      r4,r0
                  |L2.342|
;;;105    		//===========================================【航向角P输出】==============================================
;;;106    	  ctrl.yaw.shell.pid_out = ctrl.yaw.shell.kp * deviation_yaw;
000156  490b              LDR      r1,|L2.388|
000158  f8d10094          LDR      r0,[r1,#0x94]  ; ctrl
00015c  4621              MOV      r1,r4
00015e  f7fffffe          BL       __aeabi_fmul
000162  4908              LDR      r1,|L2.388|
000164  f8c100b4          STR      r0,[r1,#0xb4]
;;;107          ctrl.ctrlRate = 0; 
000168  2000              MOVS     r0,#0
00016a  7008              STRB     r0,[r1,#0]
                  |L2.364|
;;;108    	}
;;;109    	ctrl.ctrlRate ++;
00016c  4805              LDR      r0,|L2.388|
00016e  7800              LDRB     r0,[r0,#0]  ; ctrl
000170  1c40              ADDS     r0,r0,#1
000172  4904              LDR      r1,|L2.388|
000174  7008              STRB     r0,[r1,#0]
;;;110        Attitude_RatePID();
000176  f7fffffe          BL       Attitude_RatePID
;;;111    	Motor_Conter();
00017a  f7fffffe          BL       Motor_Conter
;;;112    }
00017e  e8bd81ff          POP      {r0-r8,pc}
;;;113    
                          ENDP

000182  0000              DCW      0x0000
                  |L2.388|
                          DCD      ctrl
                  |L2.392|
                          DCD      AngE
                  |L2.396|
                          DCD      0x43340000
                  |L2.400|
                          DCD      0xc3340000

                          AREA ||i.Calculate_Target||, CODE, READONLY, ALIGN=2

                  Calculate_Target PROC
;;;32     /*====================================================================================================*/
;;;33     void Calculate_Target(void) //=======此函数修改【target】结构体=======//
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;34     {
;;;35     	int16_t ftemp=0;   //此处并不是需要360°控制  只需要在小角度范围控制  
000004  2400              MOVS     r4,#0
;;;36     	                   //遥控原始数据【1000――2000】
;;;37     	Target.Pitch = (1500-RC_Data.PITCH)/(20 + 7*RC_Data.SENSITIVITY);  // 期望的目标量   【Target.Pitch】
000006  483f              LDR      r0,|L3.260|
000008  f9b0000a          LDRSH    r0,[r0,#0xa]  ; RC_Data
00000c  f24051dc          MOV      r1,#0x5dc
000010  1a09              SUBS     r1,r1,r0
000012  483c              LDR      r0,|L3.260|
000014  f9b00010          LDRSH    r0,[r0,#0x10]  ; RC_Data
000018  ebc000c0          RSB      r0,r0,r0,LSL #3
00001c  3014              ADDS     r0,r0,#0x14
00001e  fb91f5f0          SDIV     r5,r1,r0
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       __aeabi_i2f
000028  4937              LDR      r1,|L3.264|
00002a  6008              STR      r0,[r1,#0]  ; Target
;;;38     	Target.Roll = (RC_Data.ROLL-1500)/(20 + 7*RC_Data.SENSITIVITY);    //                【Target.Roll 】
00002c  4835              LDR      r0,|L3.260|
00002e  f9b00008          LDRSH    r0,[r0,#8]  ; RC_Data
000032  f2a050dc          SUB      r0,r0,#0x5dc
000036  4933              LDR      r1,|L3.260|
000038  f9b11010          LDRSH    r1,[r1,#0x10]  ; RC_Data
00003c  ebc101c1          RSB      r1,r1,r1,LSL #3
000040  3114              ADDS     r1,r1,#0x14
000042  fb90f5f1          SDIV     r5,r0,r1
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       __aeabi_i2f
00004c  492e              LDR      r1,|L3.264|
00004e  6048              STR      r0,[r1,#4]  ; Target
;;;39                          //±500范围  除以固定数值进一步减小其范围   调节RC_Data.SENSITIVITY值即可调节遥控器灵敏度
;;;40     	
;;;41       //目标航向控制。当油门大于最小检查值时，认为用户希望起飞。那么此时的航向做为目标航向
;;;42     	
;;;43        if(RC_Data.THROTTLE > RC_MINCHECK ) {  // 如果油门值大于最小起飞限定值  此处为油门原始值1200――1800
000050  482c              LDR      r0,|L3.260|
000052  f9b0000c          LDRSH    r0,[r0,#0xc]  ; RC_Data
000056  f5b06f96          CMP      r0,#0x4b0
00005a  dd0b              BLE      |L3.116|
;;;44           if(flag.LockYaw != 1){              // 航向锁定
00005c  482b              LDR      r0,|L3.268|
00005e  7940              LDRB     r0,[r0,#5]  ; flag
000060  2801              CMP      r0,#1
000062  d00e              BEQ      |L3.130|
;;;45     				 flag.LockYaw = 1;
000064  2001              MOVS     r0,#1
000066  4929              LDR      r1,|L3.268|
000068  7148              STRB     r0,[r1,#5]
;;;46     	       Target.Yaw = AngE.Yaw; //将当前的航向做为目标航向                             【 Target.Yaw 】
00006a  4829              LDR      r0,|L3.272|
00006c  6880              LDR      r0,[r0,#8]  ; AngE
00006e  4926              LDR      r1,|L3.264|
000070  6088              STR      r0,[r1,#8]  ; Target
000072  e006              B        |L3.130|
                  |L3.116|
;;;47           }
;;;48        }
;;;49        else {
;;;50     		 flag.LockYaw = 0;	        //起飞锁定航向
000074  2000              MOVS     r0,#0
000076  4925              LDR      r1,|L3.268|
000078  7148              STRB     r0,[r1,#5]
;;;51     		 Target.Yaw = AngE.Yaw;     //将当前的航向做为目标航向                          【航向角的处理较为繁琐】
00007a  4825              LDR      r0,|L3.272|
00007c  6880              LDR      r0,[r0,#8]  ; AngE
00007e  4922              LDR      r1,|L3.264|
000080  6088              STR      r0,[r1,#8]  ; Target
                  |L3.130|
;;;52     	 } 
;;;53     	//航向在中点设置一个死区
;;;54     	if((RC_Data.YAW > 1600)||(RC_Data.YAW < 1400)){     // 不轻易改变航向角
000082  4820              LDR      r0,|L3.260|
000084  f9b0000e          LDRSH    r0,[r0,#0xe]  ; RC_Data
000088  f5b06fc8          CMP      r0,#0x640
00008c  dc05              BGT      |L3.154|
00008e  481d              LDR      r0,|L3.260|
000090  f9b0000e          LDRSH    r0,[r0,#0xe]  ; RC_Data
000094  f5b06faf          CMP      r0,#0x578
000098  da32              BGE      |L3.256|
                  |L3.154|
;;;55     		ftemp = 1500 - RC_Data.YAW; 
00009a  481a              LDR      r0,|L3.260|
00009c  89c0              LDRH     r0,[r0,#0xe]  ; RC_Data
00009e  f24051dc          MOV      r1,#0x5dc
0000a2  1a08              SUBS     r0,r1,r0
0000a4  b204              SXTH     r4,r0
;;;56     	  Target.Yaw += (ftemp / 200.0f)*0.1f;              // 目标航向角加遥控器数据
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       __aeabi_i2f
0000ac  4607              MOV      r7,r0
0000ae  4919              LDR      r1,|L3.276|
0000b0  f7fffffe          BL       __aeabi_fdiv
0000b4  4606              MOV      r6,r0
0000b6  4918              LDR      r1,|L3.280|
0000b8  f7fffffe          BL       __aeabi_fmul
0000bc  4605              MOV      r5,r0
0000be  4812              LDR      r0,|L3.264|
0000c0  6881              LDR      r1,[r0,#8]  ; Target
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       __aeabi_fadd
0000c8  490f              LDR      r1,|L3.264|
0000ca  6088              STR      r0,[r1,#8]  ; Target
;;;57     		
;;;58     		//转[-180.0,+180.0]
;;;59     	  if(Target.Yaw >180.0f) Target.Yaw -= 360.0f;	
0000cc  6888              LDR      r0,[r1,#8]  ; Target
0000ce  4913              LDR      r1,|L3.284|
0000d0  f7fffffe          BL       __aeabi_cfrcmple
0000d4  d207              BCS      |L3.230|
0000d6  490c              LDR      r1,|L3.264|
0000d8  6888              LDR      r0,[r1,#8]  ; Target
0000da  4911              LDR      r1,|L3.288|
0000dc  f7fffffe          BL       __aeabi_fsub
0000e0  4909              LDR      r1,|L3.264|
0000e2  6088              STR      r0,[r1,#8]  ; Target
0000e4  e00c              B        |L3.256|
                  |L3.230|
;;;60     	  else if(Target.Yaw <-180.0f)Target.Yaw += 360.0f;
0000e6  4908              LDR      r1,|L3.264|
0000e8  6888              LDR      r0,[r1,#8]  ; Target
0000ea  490e              LDR      r1,|L3.292|
0000ec  f7fffffe          BL       __aeabi_cfcmple
0000f0  d206              BCS      |L3.256|
0000f2  4905              LDR      r1,|L3.264|
0000f4  6888              LDR      r0,[r1,#8]  ; Target
0000f6  490a              LDR      r1,|L3.288|
0000f8  f7fffffe          BL       __aeabi_fadd
0000fc  4902              LDR      r1,|L3.264|
0000fe  6088              STR      r0,[r1,#8]  ; Target
                  |L3.256|
;;;61     	}
;;;62     }
000100  e8bd81f0          POP      {r4-r8,pc}
;;;63     
                          ENDP

                  |L3.260|
                          DCD      RC_Data
                  |L3.264|
                          DCD      Target
                  |L3.268|
                          DCD      flag
                  |L3.272|
                          DCD      AngE
                  |L3.276|
                          DCD      0x43480000
                  |L3.280|
                          DCD      0x3dcccccd
                  |L3.284|
                          DCD      0x43340000
                  |L3.288|
                          DCD      0x43b40000
                  |L3.292|
                          DCD      0xc3340000

                          AREA ||i.Motor_Conter||, CODE, READONLY, ALIGN=2

                  Motor_Conter PROC
;;;180    /*====================================================================================================*/
;;;181    void Motor_Conter(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;182    {
000004  b08b              SUB      sp,sp,#0x2c
;;;183    	s16 pitch,roll,yaw;
;;;184    	
;;;185    	pitch = ctrl.pitch.core.pid_out;
000006  4940              LDR      r1,|L4.264|
000008  6c88              LDR      r0,[r1,#0x48]
00000a  f7fffffe          BL       __aeabi_f2iz
00000e  b204              SXTH     r4,r0
;;;186        roll  = ctrl.roll.core.pid_out;    
000010  493d              LDR      r1,|L4.264|
000012  f8d10090          LDR      r0,[r1,#0x90]
000016  f7fffffe          BL       __aeabi_f2iz
00001a  fa0ff980          SXTH     r9,r0
;;;187     	yaw   = -ctrl.yaw.core.pid_out;
00001e  483a              LDR      r0,|L4.264|
000020  f8d000d8          LDR      r0,[r0,#0xd8]
000024  f0804500          EOR      r5,r0,#0x80000000
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       __aeabi_f2iz
00002e  fa0ffa80          SXTH     r10,r0
;;;188        //遥控器输出油门量1000-2000  遥控器输出油门量需经处理后作为电机输出油门量
;;;189      if(RC_Data.THROTTLE > RC_MINCHECK) {  //如果油门值大于最小起飞标定值 确定可以起飞 油门原始值1200-1800
000032  4836              LDR      r0,|L4.268|
000034  f9b0000c          LDRSH    r0,[r0,#0xc]  ; RC_Data
000038  f5b06f96          CMP      r0,#0x4b0
00003c  dd51              BLE      |L4.226|
;;;190    		int date_throttle	= (RC_Data.THROTTLE-1000)/cos(AngE.Roll/RtA)/cos(AngE.Pitch/RtA);  //油门曲线
00003e  4934              LDR      r1,|L4.272|
000040  6808              LDR      r0,[r1,#0]  ; AngE
000042  f7fffffe          BL       __aeabi_f2d
000046  4607              MOV      r7,r0
000048  4a32              LDR      r2,|L4.276|
00004a  4b33              LDR      r3,|L4.280|
00004c  f7fffffe          BL       __aeabi_ddiv
000050  4605              MOV      r5,r0
000052  f7fffffe          BL       ||cos||
000056  e9cd0106          STRD     r0,r1,[sp,#0x18]
00005a  492d              LDR      r1,|L4.272|
00005c  6848              LDR      r0,[r1,#4]  ; AngE
00005e  f7fffffe          BL       __aeabi_f2d
000062  4605              MOV      r5,r0
000064  4a2b              LDR      r2,|L4.276|
000066  4b2c              LDR      r3,|L4.280|
000068  f7fffffe          BL       __aeabi_ddiv
00006c  e9cd0100          STRD     r0,r1,[sp,#0]
000070  f7fffffe          BL       ||cos||
000074  e9cd0102          STRD     r0,r1,[sp,#8]
000078  4924              LDR      r1,|L4.268|
00007a  f9b1100c          LDRSH    r1,[r1,#0xc]  ; RC_Data
00007e  f5a1707a          SUB      r0,r1,#0x3e8
000082  f7fffffe          BL       __aeabi_i2d
000086  4607              MOV      r7,r0
000088  e9dd2302          LDRD     r2,r3,[sp,#8]
00008c  f7fffffe          BL       __aeabi_ddiv
000090  e9cd0104          STRD     r0,r1,[sp,#0x10]
000094  e9dd2306          LDRD     r2,r3,[sp,#0x18]
000098  f7fffffe          BL       __aeabi_ddiv
00009c  e9cd0108          STRD     r0,r1,[sp,#0x20]
0000a0  f7fffffe          BL       __aeabi_d2iz
0000a4  4683              MOV      r11,r0
;;;191    		//原始油门为线性 响应过快 需经一定手段处理使其变为非线性
;;;192    		#ifdef QUADROTOR           //四轴
;;;193    			Moto_duty[0] = date_throttle - pitch - roll + yaw;       //【姿态控制是在油门的基础之上的】
0000a6  ebab0004          SUB      r0,r11,r4
0000aa  eba00009          SUB      r0,r0,r9
0000ae  4450              ADD      r0,r0,r10
0000b0  b200              SXTH     r0,r0
0000b2  491a              LDR      r1,|L4.284|
0000b4  8008              STRH     r0,[r1,#0]
;;;194    			Moto_duty[1] = date_throttle - pitch + roll - yaw;    
0000b6  ebab0004          SUB      r0,r11,r4
0000ba  4448              ADD      r0,r0,r9
0000bc  eba0000a          SUB      r0,r0,r10
0000c0  b200              SXTH     r0,r0
0000c2  8048              STRH     r0,[r1,#2]
;;;195    			Moto_duty[2] = date_throttle + pitch + roll + yaw;       
0000c4  eb0b0004          ADD      r0,r11,r4
0000c8  4448              ADD      r0,r0,r9
0000ca  4450              ADD      r0,r0,r10
0000cc  b200              SXTH     r0,r0
0000ce  8088              STRH     r0,[r1,#4]
;;;196    			Moto_duty[3] = date_throttle + pitch - roll - yaw;
0000d0  eb0b0004          ADD      r0,r11,r4
0000d4  eba00009          SUB      r0,r0,r9
0000d8  eba0000a          SUB      r0,r0,r10
0000dc  b200              SXTH     r0,r0
0000de  80c8              STRH     r0,[r1,#6]
;;;197    		#elif defined HEXRCOPTER   //六轴
;;;198    			Moto_duty[0] = date_throttle - pitch + 0.5*roll - yaw;
;;;199    			Moto_duty[1] = date_throttle         +     roll + yaw;
;;;200    			Moto_duty[2] = date_throttle + pitch + 0.5*roll - yaw;
;;;201    			Moto_duty[3] = date_throttle + pitch - 0.5*roll + yaw;	
;;;202    			Moto_duty[4] = date_throttle         -     roll - yaw;
;;;203    			Moto_duty[5] = date_throttle - pitch - 0.5*roll + yaw;	
;;;204    		#endif 	
;;;205    	}
0000e0  e006              B        |L4.240|
                  |L4.226|
;;;206    	else
;;;207    	{	                                              //如果油门值小于最小起飞限定值
;;;208    		array_assign(&Moto_duty[0],IDLING,MOTOR_NUM); //数组写入函数 电机任务数组 都写为电机怠速值
0000e2  2204              MOVS     r2,#4
0000e4  21d2              MOVS     r1,#0xd2
0000e6  480d              LDR      r0,|L4.284|
0000e8  f7fffffe          BL       array_assign
;;;209    		Reset_Integral();		//积分清零
0000ec  f7fffffe          BL       Reset_Integral
                  |L4.240|
;;;210    	}
;;;211    	if(flag.ARMED)  moto_PwmRflash(&Moto_duty[0]);	//解锁后电机才可以转	
0000f0  480b              LDR      r0,|L4.288|
0000f2  7900              LDRB     r0,[r0,#4]  ; flag
0000f4  b118              CBZ      r0,|L4.254|
0000f6  4809              LDR      r0,|L4.284|
0000f8  f7fffffe          BL       moto_PwmRflash
0000fc  e001              B        |L4.258|
                  |L4.254|
;;;212    	else            moto_STOP();	                  //不解锁电机不转
0000fe  f7fffffe          BL       moto_STOP
                  |L4.258|
;;;213    }
000102  b00b              ADD      sp,sp,#0x2c
000104  e8bd8ff0          POP      {r4-r11,pc}
;;;214    
                          ENDP

                  |L4.264|
                          DCD      ctrl
                  |L4.268|
                          DCD      RC_Data
                  |L4.272|
                          DCD      AngE
                  |L4.276|
                          DCD      0x63cfb331
                  |L4.280|
                          DCD      0x404ca994
                  |L4.284|
                          DCD      Moto_duty
                  |L4.288|
                          DCD      flag

                          AREA ||i.Reset_Integral||, CODE, READONLY, ALIGN=2

                  Reset_Integral PROC
;;;223    /*====================================================================================================*/
;;;224    void Reset_Integral(void)
000000  2100              MOVS     r1,#0
;;;225    {
;;;226    	ctrl.pitch.shell.increment = 0;  //外环
000002  4804              LDR      r0,|L5.20|
000004  6101              STR      r1,[r0,#0x10]
;;;227    	ctrl.roll.shell.increment= 0;	
000006  6581              STR      r1,[r0,#0x58]
;;;228        ctrl.pitch.core.increment = 0;	 //内环
000008  6341              STR      r1,[r0,#0x34]
;;;229        ctrl.roll.core.increment = 0;		
00000a  67c1              STR      r1,[r0,#0x7c]
;;;230    	ctrl.yaw.core.increment = 0;
00000c  f8c010c4          STR      r1,[r0,#0xc4]
;;;231    }
000010  4770              BX       lr
;;;232    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      ctrl

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ctrl
                          %        220
                  Target
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  Moto_duty
                          %        8
                  motor_array
                          DCD      Moto_duty

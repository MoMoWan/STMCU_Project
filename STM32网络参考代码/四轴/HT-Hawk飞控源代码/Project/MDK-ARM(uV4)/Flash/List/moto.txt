; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections -c --asm --interleave -o.\flash\obj\moto.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\moto.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\moto.crf ..\..\User\Driver\MOTOR\moto.c]
                          THUMB

                          AREA ||i.PWM_OUT_Config||, CODE, READONLY, ALIGN=2

                  PWM_OUT_Config PROC
;;;97     
;;;98     void PWM_OUT_Config(void) //========================================================【PWM输出GPIO配置】
000000  b508              PUSH     {r3,lr}
;;;99     {
;;;100    	GPIO_InitTypeDef GPIO_InitStructure; //=========================【GPIOB-6-7-8-9】 【TIM4 四通道PWM输出】
;;;101    
;;;102      /* GPIOA and GPIOC clock enable */
;;;103      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;104    
;;;105    	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
00000a  f44f7070          MOV      r0,#0x3c0
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;106      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;		    // 复用推挽输出
000012  2018              MOVS     r0,#0x18
000014  f88d0003          STRB     r0,[sp,#3]
;;;107      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;108    	GPIO_Init(GPIOB, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  480c              LDR      r0,|L1.84|
000022  f7fffffe          BL       GPIO_Init
;;;109    	
;;;110    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); 
000026  2101              MOVS     r1,#1
000028  2040              MOVS     r0,#0x40
00002a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;111                                         //===========================【GPIOE-9-11-13-14】 【TIM1 四通道PWM输出】【未用】
;;;112    	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_9 | GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
00002e  f44f40d4          MOV      r0,#0x6a00
000032  f8ad0000          STRH     r0,[sp,#0]
;;;113      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;		    // 复用推挽输出
000036  2018              MOVS     r0,#0x18
000038  f88d0003          STRB     r0,[sp,#3]
;;;114      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003c  2003              MOVS     r0,#3
00003e  f88d0002          STRB     r0,[sp,#2]
;;;115    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4804              LDR      r0,|L1.88|
000046  f7fffffe          BL       GPIO_Init
;;;116    	
;;;117    	Tim4_init();	
00004a  f7fffffe          BL       Tim4_init
;;;118    	Tim1_init();
00004e  f7fffffe          BL       Tim1_init
;;;119    }
000052  bd08              POP      {r3,pc}
;;;120    
                          ENDP

                  |L1.84|
                          DCD      0x40010c00
                  |L1.88|
                          DCD      0x40011800

                          AREA ||i.Tim1_init||, CODE, READONLY, ALIGN=2

                  Tim1_init PROC
;;;11     
;;;12     void Tim1_init(void)        //TIM1  为高级定时器  【预留通道】 未用
000000  b500              PUSH     {lr}
;;;13     {
000002  b087              SUB      sp,sp,#0x1c
;;;14     	TIM_TimeBaseInitTypeDef		TIM_TimeBaseStructure;
;;;15     	TIM_OCInitTypeDef  				TIM_OCInitStructure;
;;;16     	
;;;17     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
000004  2101              MOVS     r1,#1
000006  02c8              LSLS     r0,r1,#11
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;18     	GPIO_PinRemapConfig(GPIO_FullRemap_TIM1 ,ENABLE);  
00000c  2101              MOVS     r1,#1
00000e  482d              LDR      r0,|L2.196|
000010  f7fffffe          BL       GPIO_PinRemapConfig
;;;19     	
;;;20     	/**********************************************************
;;;21     	72 000 000/72=1M
;;;22     	1000 000/2500=400Hz
;;;23     	所以产生的PWM为400Hz
;;;24     	周期为2.5ms，对应2500的计算值，1ms~2ms对应的计算值为1000~2000；
;;;25     	**********************************************************/
;;;26     	TIM_TimeBaseStructure.TIM_Period = 2499;		  //计数上线	2500
000014  f64010c3          MOV      r0,#0x9c3
000018  f8ad0014          STRH     r0,[sp,#0x14]
;;;27     	TIM_TimeBaseStructure.TIM_Prescaler = 71; 	  //pwm时钟分频
00001c  2047              MOVS     r0,#0x47
00001e  f8ad0010          STRH     r0,[sp,#0x10]
;;;28     	TIM_TimeBaseStructure.TIM_ClockDivision = 0;	
000022  2000              MOVS     r0,#0
000024  f8ad0016          STRH     r0,[sp,#0x16]
;;;29     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;		//向上计数
000028  f8ad0012          STRH     r0,[sp,#0x12]
;;;30     	TIM_TimeBaseStructure.TIM_RepetitionCounter=0;//重复寄存器，用于自动更新pwm占空比
00002c  f88d0018          STRB     r0,[sp,#0x18]
;;;31     	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);//===================================================【时基初始化】
000030  a904              ADD      r1,sp,#0x10
000032  4825              LDR      r0,|L2.200|
000034  f7fffffe          BL       TIM_TimeBaseInit
;;;32     	
;;;33     	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
000038  2060              MOVS     r0,#0x60
00003a  f8ad0000          STRH     r0,[sp,#0]
;;;34     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
00003e  2001              MOVS     r0,#1
000040  f8ad0002          STRH     r0,[sp,#2]
;;;35     	TIM_OCInitStructure.TIM_Pulse = 1000;         //电平跳变计数值
000044  f44f707a          MOV      r0,#0x3e8
000048  f8ad0006          STRH     r0,[sp,#6]
;;;36     	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
00004c  2000              MOVS     r0,#0
00004e  f8ad0008          STRH     r0,[sp,#8]
;;;37     	
;;;38     	//下面几个参数是高级定时器才会用到，通用定时器不用配置
;;;39         TIM_OCInitStructure.TIM_OCNPolarity=TIM_OCNPolarity_Low;     //设置互补端输出极性
000052  2008              MOVS     r0,#8
000054  f8ad000a          STRH     r0,[sp,#0xa]
;;;40     	TIM_OCInitStructure.TIM_OutputNState=TIM_OutputNState_Enable;//使能互补端输出
000058  2004              MOVS     r0,#4
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;41     	TIM_OCInitStructure.TIM_OCIdleState=TIM_OCIdleState_Reset;   //死区后输出状态
00005e  2000              MOVS     r0,#0
000060  f8ad000c          STRH     r0,[sp,#0xc]
;;;42     	TIM_OCInitStructure.TIM_OCNIdleState=TIM_OCNIdleState_Reset; //死区后互补端输出状态
000064  f8ad000e          STRH     r0,[sp,#0xe]
;;;43     	//==================================================================================================【各通道输出模式配置】
;;;44     	TIM_OC1Init(TIM1, &TIM_OCInitStructure);          //初始化通道一
000068  4669              MOV      r1,sp
00006a  4817              LDR      r0,|L2.200|
00006c  f7fffffe          BL       TIM_OC1Init
;;;45     	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);                   //使能通道一比较寄存器 【CCR】
000070  2108              MOVS     r1,#8
000072  4815              LDR      r0,|L2.200|
000074  f7fffffe          BL       TIM_OC1PreloadConfig
;;;46     	TIM_OC2Init(TIM1, &TIM_OCInitStructure);          //初始化通道二
000078  4669              MOV      r1,sp
00007a  4813              LDR      r0,|L2.200|
00007c  f7fffffe          BL       TIM_OC2Init
;;;47     	TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);                   //使能通道二比较寄存器 【CCR】
000080  2108              MOVS     r1,#8
000082  4811              LDR      r0,|L2.200|
000084  f7fffffe          BL       TIM_OC2PreloadConfig
;;;48     	TIM_OC3Init(TIM1, &TIM_OCInitStructure);          //初始化通道三
000088  4669              MOV      r1,sp
00008a  480f              LDR      r0,|L2.200|
00008c  f7fffffe          BL       TIM_OC3Init
;;;49     	TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);                   //使能通道三比较寄存器 【CCR】
000090  2108              MOVS     r1,#8
000092  480d              LDR      r0,|L2.200|
000094  f7fffffe          BL       TIM_OC3PreloadConfig
;;;50     	TIM_OC4Init(TIM1, &TIM_OCInitStructure);          //初始化通道四
000098  4669              MOV      r1,sp
00009a  480b              LDR      r0,|L2.200|
00009c  f7fffffe          BL       TIM_OC4Init
;;;51     	TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);                   //使能通道四比较寄存器 【CCR】
0000a0  2108              MOVS     r1,#8
0000a2  4809              LDR      r0,|L2.200|
0000a4  f7fffffe          BL       TIM_OC4PreloadConfig
;;;52     	
;;;53     	TIM_ARRPreloadConfig(TIM1, ENABLE);//使能重装载寄存器 【ARR】
0000a8  2101              MOVS     r1,#1
0000aa  4807              LDR      r0,|L2.200|
0000ac  f7fffffe          BL       TIM_ARRPreloadConfig
;;;54     	TIM_Cmd(TIM1, ENABLE);             //使能 【TIM1】
0000b0  2101              MOVS     r1,#1
0000b2  4805              LDR      r0,|L2.200|
0000b4  f7fffffe          BL       TIM_Cmd
;;;55       TIM_CtrlPWMOutputs(TIM1, ENABLE);
0000b8  2101              MOVS     r1,#1
0000ba  4803              LDR      r0,|L2.200|
0000bc  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;56     }
0000c0  b007              ADD      sp,sp,#0x1c
0000c2  bd00              POP      {pc}
;;;57     
                          ENDP

                  |L2.196|
                          DCD      0x001600c0
                  |L2.200|
                          DCD      0x40012c00

                          AREA ||i.Tim4_init||, CODE, READONLY, ALIGN=2

                  Tim4_init PROC
;;;59     
;;;60     void Tim4_init(void)//************************************************//【TIM4 PWM输出配置】
000000  b500              PUSH     {lr}
;;;61     {                                                                     //【电机输出四通道】
000002  b087              SUB      sp,sp,#0x1c
;;;62     	TIM_TimeBaseInitTypeDef		TIM_TimeBaseStructure;
;;;63     	TIM_OCInitTypeDef  				TIM_OCInitStructure;
;;;64     	
;;;65     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;66     	/******************************************************************
;;;67     	72 000 000/72=1M
;;;68     	1000 000/2500=400Hz
;;;69     //===================================================================》》》》》】
;;;70      【所以产生的PWM为400Hz】                                            》》》》》】
;;;71      【周期为2.5ms，对应2500的计算值】，【1ms~2ms对应的计算值为1000~2000】 》》》》】
;;;72     //===================================================================》》》》》】
;;;73     	******************************************************************/
;;;74     	TIM_TimeBaseStructure.TIM_Period = 2499;		//计数上线	
00000c  f64010c3          MOV      r0,#0x9c3
000010  f8ad0014          STRH     r0,[sp,#0x14]
;;;75     	TIM_TimeBaseStructure.TIM_Prescaler = 71;  	//pwm时钟分频
000014  2047              MOVS     r0,#0x47
000016  f8ad0010          STRH     r0,[sp,#0x10]
;;;76     	TIM_TimeBaseStructure.TIM_ClockDivision = 0;	
00001a  2000              MOVS     r0,#0
00001c  f8ad0016          STRH     r0,[sp,#0x16]
;;;77     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;		//向上计数
000020  f8ad0012          STRH     r0,[sp,#0x12]
;;;78     	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
000024  a904              ADD      r1,sp,#0x10
000026  481d              LDR      r0,|L3.156|
000028  f7fffffe          BL       TIM_TimeBaseInit
;;;79     	
;;;80     	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
00002c  2060              MOVS     r0,#0x60
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;81     	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
000032  2001              MOVS     r0,#1
000034  f8ad0002          STRH     r0,[sp,#2]
;;;82     	TIM_OCInitStructure.TIM_Pulse = 1000;
000038  f44f707a          MOV      r0,#0x3e8
00003c  f8ad0006          STRH     r0,[sp,#6]
;;;83     	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
000040  2000              MOVS     r0,#0
000042  f8ad0008          STRH     r0,[sp,#8]
;;;84     	
;;;85     	TIM_OC1Init(TIM4, &TIM_OCInitStructure);
000046  4669              MOV      r1,sp
000048  4814              LDR      r0,|L3.156|
00004a  f7fffffe          BL       TIM_OC1Init
;;;86     	TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
00004e  2108              MOVS     r1,#8
000050  4812              LDR      r0,|L3.156|
000052  f7fffffe          BL       TIM_OC1PreloadConfig
;;;87     	TIM_OC2Init(TIM4, &TIM_OCInitStructure);
000056  4669              MOV      r1,sp
000058  4810              LDR      r0,|L3.156|
00005a  f7fffffe          BL       TIM_OC2Init
;;;88     	TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
00005e  2108              MOVS     r1,#8
000060  480e              LDR      r0,|L3.156|
000062  f7fffffe          BL       TIM_OC2PreloadConfig
;;;89     	TIM_OC3Init(TIM4, &TIM_OCInitStructure);
000066  4669              MOV      r1,sp
000068  480c              LDR      r0,|L3.156|
00006a  f7fffffe          BL       TIM_OC3Init
;;;90     	TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable);
00006e  2108              MOVS     r1,#8
000070  480a              LDR      r0,|L3.156|
000072  f7fffffe          BL       TIM_OC3PreloadConfig
;;;91     	TIM_OC4Init(TIM4, &TIM_OCInitStructure);
000076  4669              MOV      r1,sp
000078  4808              LDR      r0,|L3.156|
00007a  f7fffffe          BL       TIM_OC4Init
;;;92     	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);
00007e  2108              MOVS     r1,#8
000080  4806              LDR      r0,|L3.156|
000082  f7fffffe          BL       TIM_OC4PreloadConfig
;;;93     	
;;;94     	TIM_ARRPreloadConfig(TIM4, ENABLE);
000086  2101              MOVS     r1,#1
000088  4804              LDR      r0,|L3.156|
00008a  f7fffffe          BL       TIM_ARRPreloadConfig
;;;95     	TIM_Cmd(TIM4, ENABLE);
00008e  2101              MOVS     r1,#1
000090  4802              LDR      r0,|L3.156|
000092  f7fffffe          BL       TIM_Cmd
;;;96     }
000096  b007              ADD      sp,sp,#0x1c
000098  bd00              POP      {pc}
;;;97     
                          ENDP

00009a  0000              DCW      0x0000
                  |L3.156|
                          DCD      0x40000800

                          AREA ||i.moto_PwmRflash||, CODE, READONLY, ALIGN=2

                  moto_PwmRflash PROC
;;;149    //============================================================================================================//
;;;150    void moto_PwmRflash(s16 *Moter)                      //循环更新四个电机PWM输出值
000000  2100              MOVS     r1,#0
;;;151    {		
;;;152    	for(u8 i=0;i<MOTOR_NUM;i++)                        //Moter[i]里存放相应电机PWM输出值
000002  e00a              B        |L4.26|
                  |L4.4|
;;;153    	{
;;;154         if(*(Moter+i) > Moto_PwmMax)  *(Moter+i) = Moto_PwmMax; //【 Moto_PwmMax=1000 】
000004  f9302011          LDRSH    r2,[r0,r1,LSL #1]
000008  f5b27f7a          CMP      r2,#0x3e8
00000c  dd03              BLE      |L4.22|
00000e  f44f727a          MOV      r2,#0x3e8
000012  f8202011          STRH     r2,[r0,r1,LSL #1]
                  |L4.22|
000016  1c4a              ADDS     r2,r1,#1              ;152
000018  b2d1              UXTB     r1,r2                 ;152
                  |L4.26|
00001a  2904              CMP      r1,#4                 ;152
00001c  dbf2              BLT      |L4.4|
;;;155      }
;;;156    	for(u8 i=0;i<MOTOR_NUM;i++)
00001e  2100              MOVS     r1,#0
000020  e008              B        |L4.52|
                  |L4.34|
;;;157    	{
;;;158         if(*(Moter+i) <= 0 )  *(Moter+i) = 0;                   //输出正反向限幅【0――1000】范围
000022  f9302011          LDRSH    r2,[r0,r1,LSL #1]
000026  2a00              CMP      r2,#0
000028  dc02              BGT      |L4.48|
00002a  2200              MOVS     r2,#0
00002c  f8202011          STRH     r2,[r0,r1,LSL #1]
                  |L4.48|
000030  1c4a              ADDS     r2,r1,#1              ;156
000032  b2d1              UXTB     r1,r2                 ;156
                  |L4.52|
000034  2904              CMP      r1,#4                 ;156
000036  dbf4              BLT      |L4.34|
;;;159      }                                                          //电机PWM输出被限定在【1ms――2ms】
;;;160    	
;;;161    	if(MOTOR_NUM ==4 ){               //【循环更新各路PWM输出CCR】
;;;162    		TIM4->CCR1 = 1000 + *(Moter++);
000038  f8301b02          LDRH     r1,[r0],#2
00003c  f501717a          ADD      r1,r1,#0x3e8
000040  4a09              LDR      r2,|L4.104|
000042  8011              STRH     r1,[r2,#0]
;;;163    		TIM4->CCR2 = 1000 + *(Moter++);
000044  f8301b02          LDRH     r1,[r0],#2
000048  f501717a          ADD      r1,r1,#0x3e8
00004c  1d12              ADDS     r2,r2,#4
00004e  8011              STRH     r1,[r2,#0]
;;;164    		TIM4->CCR3 = 1000 + *(Moter++);
000050  f8301b02          LDRH     r1,[r0],#2
000054  f501717a          ADD      r1,r1,#0x3e8
000058  1d12              ADDS     r2,r2,#4
00005a  8011              STRH     r1,[r2,#0]
;;;165    		TIM4->CCR4 = 1000 + *Moter;
00005c  8801              LDRH     r1,[r0,#0]
00005e  f501717a          ADD      r1,r1,#0x3e8
000062  1d12              ADDS     r2,r2,#4
000064  8011              STRH     r1,[r2,#0]
;;;166    	}
;;;167    	else if(MOTOR_NUM == 6){          //六轴
;;;168    		TIM4->CCR1 = 1000 + *(Moter++);
;;;169    		TIM4->CCR2 = 1000 + *(Moter++);
;;;170    		TIM4->CCR3 = 1000 + *(Moter++);
;;;171    		TIM4->CCR4 = 1000 + *(Moter++);
;;;172    		TIM1->CCR1 = 1000 + *(Moter++);
;;;173    		TIM1->CCR2 = 1000 + *Moter;
;;;174    	}
;;;175    }
000066  4770              BX       lr
;;;176    
                          ENDP

                  |L4.104|
                          DCD      0x40000834

                          AREA ||i.moto_STOP||, CODE, READONLY, ALIGN=2

                  moto_STOP PROC
;;;176    
;;;177    void moto_STOP(void)        //电机怠速  
000000  f44f707a          MOV      r0,#0x3e8
;;;178    {
;;;179    	if(MOTOR_NUM ==4 ){	      //四轴        四轴使用 TIM4四路PWM输出控制
;;;180    		TIM4->CCR1 = 1000;
000004  4904              LDR      r1,|L5.24|
000006  8008              STRH     r0,[r1,#0]
;;;181    		TIM4->CCR2 = 1000;
000008  1d09              ADDS     r1,r1,#4
00000a  8008              STRH     r0,[r1,#0]
;;;182    		TIM4->CCR3 = 1000;
00000c  1d09              ADDS     r1,r1,#4
00000e  8008              STRH     r0,[r1,#0]
;;;183    		TIM4->CCR4 = 1000;
000010  1d09              ADDS     r1,r1,#4
000012  8008              STRH     r0,[r1,#0]
;;;184    	}
;;;185    	else if(MOTOR_NUM == 6){  //六轴        六轴使用 TIM4四路 TIM1两路PWM输出控制
;;;186    		TIM4->CCR1 = 1000;
;;;187    		TIM4->CCR2 = 1000;
;;;188    		TIM4->CCR3 = 1000;
;;;189    		TIM4->CCR4 = 1000;
;;;190    		TIM1->CCR1 = 1000;
;;;191    		TIM1->CCR2 = 1000;
;;;192    	}
;;;193    }
000014  4770              BX       lr
;;;194    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x40000834

                          AREA ||i.pwmWriteMotor||, CODE, READONLY, ALIGN=1

                  pwmWriteMotor PROC
;;;130    /*====================================================================================================*/
;;;131    void pwmWriteMotor(uint8_t index, uint16_t value)    //【此函数没有用到】
000000  f5b17f7a          CMP      r1,#0x3e8
;;;132    {    
;;;133    	if(value > Moto_PwmMax)  value = Moto_PwmMax;      //输出正反向限幅
000004  dd01              BLE      |L6.10|
000006  f44f717a          MOV      r1,#0x3e8
                  |L6.10|
;;;134    	if(value <= 0)           value = 0;                //应联系PWM输出周期参数
00000a  2900              CMP      r1,#0
00000c  dc00              BGT      |L6.16|
00000e  2100              MOVS     r1,#0
                  |L6.16|
;;;135    	// pwmWritePtr(index, value);
;;;136    }
000010  4770              BX       lr
;;;137    
                          ENDP


                          AREA ||i.writeMotors||, CODE, READONLY, ALIGN=1

                  writeMotors PROC
;;;137    
;;;138    void writeMotors(int16_t *Moter)                     //循环检查四个电机PWM数值
000000  b510              PUSH     {r4,lr}
;;;139    {
000002  4604              MOV      r4,r0
;;;140        uint8_t i;
;;;141    
;;;142        for (i = 0; i < 4; i++)
000004  2300              MOVS     r3,#0
000006  e007              B        |L7.24|
                  |L7.8|
;;;143            pwmWriteMotor(i, Moter[i]);                  //【i】电机号； 【Moter[i]】PWM写入值
000008  f8340013          LDRH     r0,[r4,r3,LSL #1]
00000c  b281              UXTH     r1,r0
00000e  4618              MOV      r0,r3
000010  f7fffffe          BL       pwmWriteMotor
000014  1c58              ADDS     r0,r3,#1              ;142
000016  b2c3              UXTB     r3,r0                 ;142
                  |L7.24|
000018  2b04              CMP      r3,#4                 ;142
00001a  dbf5              BLT      |L7.8|
;;;144    }
00001c  bd10              POP      {r4,pc}
;;;145    
                          ENDP

